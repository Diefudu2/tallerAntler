grammar Simple;

@parser::header{
    import java.util.Map;
    import java.util.HashMap;
}
@parser::members{
}

program: PROGRAM ID BRACKET_OPEN 
    sentence*
    BRACKET_CLOSE;

sentence returns [ASTNode node]:  println | conditional;


    
println returns [ASTNode node]: PRINTLN expression SEMICOLON
    {$node = new Println($expression.node);};
    
conditional returns [ASTNode node]: IF PAR_OPEN expression PAR_CLOSE
			{
				List<ASTNode> body = new ArrayList<ASTNode>();
			}
			BRACKET_OPEN (s1=sentence{body.add($s1.node);})* BRACKET CLOSE
			ELSE
			{
				List<ASTNode> elseBody = new ArrayList<ASTNode>();
			}
			BRACKET_OPEN (s2=sentence{elseBody.add($s1.node);})* BRACKET CLOSE
			{
				$node = new If($expression.node,body,elseBody);
			};


expression returns [ASTNode node]: 
    t1=term {}
    ( (PLUS t2=term {})
    | (MINUS t2=term {})
    )*;

term returns [ASTNode node]: 
    t1=factor {}
    ( (MULT t2=factor {})
    | (DIV t2=factor {})
    )*;

factor returns [ASTNode node]:
    t1=exponent {}
    (EXP t2=exponent {})*;

exponent returns [ASTNode node]: 
    t1=primary {}
    (EXP t2=primary {})?;

primary returns [ASTNode node]: 
    NUMBER {}
    | ID {}
    | BOOLEAN {}
    | PAR_OPEN expression {} PAR_CLOSE;

// TOKENS
PROGRAM: 'program';
VAR: 'var';
PRINTLN: 'println';
IF: 'if';
ELSE: 'else';

PLUS: '+';
MINUS: '-';
MULT: '*';
DIV: '/';
EXP: '^';  // Operador exponencial

AND: '&&';
OR: '||';
NOT: '!';

GT: '>';
LT: '<';
GEQ: '>=';
LEQ: '<=';
EQ: '==';
NEQ: '!=';

ASSIGN: '=';

BRACKET_OPEN: '{';
BRACKET_CLOSE: '}';

PAR_OPEN: '(';
PAR_CLOSE: ')';

SEMICOLON: ';';

BOOLEAN: 'true' | 'false';

ID: [a-zA-Z_][a-zA-Z0-9_]*;

// Corregido para aceptar números de más de un dígito
NUMBER: [0-9]+;

WS: [ \t\n\r]+ -> skip;