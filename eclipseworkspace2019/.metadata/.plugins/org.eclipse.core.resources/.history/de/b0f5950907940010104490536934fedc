grammar Simple;

@parser::header{
    import java.util.Map;
    import java.util.HashMap;
    import java.util.List;
    import java.util.ArrayList;
    import com.miorganizacion.simple.interprete.ast.*;
}
@parser::members{
    Map<String, Object> symbolTable = new HashMap<String, Object>();
}

program: PROGRAM ID BRACKET_OPEN 
	{
		List<ASTNode> body = new ArrayList<ASTNode>();
	}
    (sentence{body.add(sentence.node);})*
    BRACKET_CLOSE
    {
    	for (ASTNode n : body){
    		n.execute();
    	}
    };

sentence returns [ASTNode node]:  
    println {$node = $println.node;} 
    | conditional {$node = $conditional.node;}
    | var_decl {$node = $var_decl.node;}
    | var_assign {$node = $var_assign.node;};

var_decl returns [ASTNode node]: VAR ID SEMICOLON
    {$node = new VarDecl($ID.text, symbolTable);};
    
var_assign returns [ASTNode node]: ID ASSIGN expression SEMICOLON
    {$node = new VarAssign($ID.text, $expression.node, symbolTable);};
    
println returns [ASTNode node]: PRINTLN expression SEMICOLON
    {$node = new Println($expression.node);};
    
conditional returns [ASTNode node]: IF PAR_OPEN expression PAR_CLOSE
    {
        List<ASTNode> body = new ArrayList<ASTNode>();
    }
    BRACKET_OPEN (s1=sentence{body.add($s1.node);})* BRACKET_CLOSE
    (ELSE
    {
        List<ASTNode> elseBody = new ArrayList<ASTNode>();
    }
    BRACKET_OPEN (s2=sentence{elseBody.add($s2.node);})* BRACKET_CLOSE
    {
        $node = new If($expression.node, body, elseBody);
    }
    | 
    {
        $node = new If($expression.node, body, null);
    });

expression returns [ASTNode node]: 
    t1=term {$node = $t1.node;}
    ( (PLUS t2=term {$node = new Addition($node, $t2.node);})
    | (MINUS t2=term {$node = new Subtraction($node, $t2.node);})
    )*;

term returns [ASTNode node]: 
    t1=factor {$node = $t1.node;}
    ( (MULT t2=factor {$node = new Multiplication($node, $t2.node);})
    | (DIV t2=factor {$node = new Division($node, $t2.node);})
    )*;

factor returns [ASTNode node]:
    t1=exponent {$node = $t1.node;}
    (EXP t2=exponent {$node = new Exponentiation($node, $t2.node);})*;

exponent returns [ASTNode node]: 
    primary {$node = $primary.node;};

primary returns [ASTNode node]: 
    NUMBER {$node = new Constant(Integer.parseInt($NUMBER.text));}
    | ID {$node = new Variable($ID.text, symbolTable);}
    | BOOLEAN {$node = new Constant(Boolean.parseBoolean($BOOLEAN.text));}
    | PAR_OPEN expression {$node = $expression.node;} PAR_CLOSE;

// TOKENS (igual que antes)
PROGRAM: 'program';
VAR: 'var';
PRINTLN: 'println';
IF: 'if';
ELSE: 'else';
PLUS: '+';
MINUS: '-';
MULT: '*';
DIV: '/';
EXP: '^';
AND: '&&';
OR: '||';
NOT: '!';
GT: '>';
LT: '<';
GEQ: '>=';
LEQ: '<=';
EQ: '==';
NEQ: '!=';
ASSIGN: '=';
BRACKET_OPEN: '{';
BRACKET_CLOSE: '}';
PAR_OPEN: '(';
PAR_CLOSE: ')';
SEMICOLON: ';';
BOOLEAN: 'true' | 'false';
ID: [a-zA-Z_][a-zA-Z0-9_]*;
NUMBER: [0-9]+;
WS: [ \t\n\r]+ -> skip;